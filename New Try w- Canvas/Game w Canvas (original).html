<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <style type="text/css">
        .default, .click_now, .warning {
            font-size: 18pt;
            text-align: center;
        }

        .blue, .default, .gauge, .bar_row, #avg_row, #med_row {
            color: #00ffff;
            background-color: #0000ff;
        }

        .green, #best_row {
            color: #ccff00;
            background-color: #008000;
        }

        .green_yellow {
            color: #ffff00;
            background-color: #008000;
        }

        .warning, .red, #worst_row {
            color: #ffff00;
            background-color: #ff0000;
        }

        .white {
            color: #000000;
            background-color: #ffffff;
        }

        #lightRow td {
            border: 1px solid black;
        }

        #touchDisplayTable input {
            border: 1px solid rgb(128,128,128);
        }
    </style>
    <title></title>
     <script language="JavaScript">
         <!--

	// Shim
	////////
	if(!Date.now)
         Date.now = function() { return (new Date()).getTime(); }

         requestAnimationFrame = window.requestAnimationFrame || 
             window.webkitRequestAnimationFrame ||
             window.mozRequestAnimationFrame ||
             window.oRequestAnimationFrame ||
             window.msRequestAnimationFrame ||
             function(callbackFunction)
             {
                 now = Date.now();
                 delay = 16 - now % 16;
                 return setTimeout(function(){callbackFunction(now + delay)}, delay);
             }

         cancelAnimationFrame = window.cancelAnimationFrame ||
             window.webkitCancelAnimationFrame ||
             window.mozCancelAnimationFrame ||
             window.oCancelAnimationFrame ||
             window.msCancelAnimationFrame ||
             function(id) {
                 clearTimeout(id);
             };

         var drawingEnabled = true;
         var notInitialized = true;



         // Utility functions
         ////////////////////

         function max(array){
             var temp = array[0];
             for(i = 1; i < array.length; ++i){
                 if(array[i] > temp)
                     temp = array[i];
             }
             return temp;
         }

         function min(array){
             var temp = array[0];
             for(i = 1; i < array.length; ++i){
                 if(array[i] < temp)
                     temp = array[i];
             }
             return temp;
         }



         // Basically a static class named MeterBufferCanvas
         var MeterBufferCanvas = new Object();

         MeterBufferCanvas.canvas = document.createElement("canvas");
         ////MeterBufferCanvas.canvas.setAttribute("width", 720);
         ////MeterBufferCanvas.canvas.setAttribute("height", 20);

         MeterBufferCanvas.canvas.setAttribute("width", 720);
         MeterBufferCanvas.canvas.setAttribute("height", 20);

         if(MeterBufferCanvas.canvas && MeterBufferCanvas.canvas.getContext)
             MeterBufferCanvas.canvasContext = MeterBufferCanvas.canvas.getContext("2d");
         else
             drawingEnabled = false;
	
         if(drawingEnabled){
             MeterBufferCanvas.canvasContext.fillStyle = "rgb(0, 255, 255)";
             MeterBufferCanvas.canvasContext.fillRect(0,0,720, 20);

             MeterBufferCanvas.canvasContext.lineWidth = 1;

             MeterBufferCanvas.canvasContext.translate(0, 0.5);

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(192, 255, 255)";
             MeterBufferCanvas.canvasContext.moveTo(0,0);
             MeterBufferCanvas.canvasContext.lineTo(720,0);
             MeterBufferCanvas.canvasContext.stroke();

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(160, 255, 255)";
             MeterBufferCanvas.canvasContext.moveTo(0,1);
             MeterBufferCanvas.canvasContext.lineTo(720,1);
             MeterBufferCanvas.canvasContext.stroke();

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(128, 255, 255)";
             MeterBufferCanvas.canvasContext.moveTo(0,2);
             MeterBufferCanvas.canvasContext.lineTo(720,2);
             MeterBufferCanvas.canvasContext.stroke();

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(0, 192, 192)";
             MeterBufferCanvas.canvasContext.moveTo(0, 18);
             MeterBufferCanvas.canvasContext.lineTo(720, 18);
             MeterBufferCanvas.canvasContext.stroke();

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(0, 160, 128)";
             MeterBufferCanvas.canvasContext.moveTo(0, 19);
             MeterBufferCanvas.canvasContext.lineTo(720, 19);
             MeterBufferCanvas.canvasContext.stroke();

             MeterBufferCanvas.canvasContext.beginPath();
             MeterBufferCanvas.canvasContext.strokeStyle = "rgb(0, 64, 64)";
             MeterBufferCanvas.canvasContext.moveTo(0, 20);
             MeterBufferCanvas.canvasContext.lineTo(720, 20);
             MeterBufferCanvas.canvasContext.stroke();



             MeterBufferCanvas.canvasContext.stroke();

		
         }


         // Grid Canvas Tool
         ////////////////////
         var GridCanvasTool = new Object();
	
         GridCanvasTool.canvas = document.createElement("canvas");
         GridCanvasTool.canvas.setAttribute("width", 800);
         GridCanvasTool.canvas.setAttribute("height", 90);
         GridCanvasTool.gridSquaresHighlighted = 0;

         if(drawingEnabled){
             GridCanvasTool.canvasContext = GridCanvasTool.canvas.getContext("2d");
         }

         // Draws the standard black grid with green lines
         GridCanvasTool.drawStandardGrid = function(){
             GridCanvasTool.gridSquaresHighlighted = 0;
             GridCanvasTool.canvasContext.fillStyle = "rgb(0, 0, 0)";
             GridCanvasTool.canvasContext.fillRect(0, 0, 800, 90);

             GridCanvasTool.canvasContext.fillStyle = "rgb(0, 192, 0)";

             GridCanvasTool.canvasContext.beginPath();

             for(var i = 1; i < 24; ++i){
                 GridCanvasTool.canvasContext.moveTo(40*i, 0);
                 GridCanvasTool.canvasContext.lineTo(40*i, 80);
             }

             GridCanvasTool.canvasContext.moveTo(0, 40);
             GridCanvasTool.canvasContext.lineTo(800, 40);

             GridCanvasTool.canvasContext.strokeStyle = "rgb(0, 192, 0)";
             GridCanvasTool.canvasContext.lineWidth = 2;
             GridCanvasTool.canvasContext.stroke();

             // Draw numbers
             GridCanvasTool.canvasContext.font="25px Arial, Helvetica, sans-serif";

             GridCanvasTool.canvasContext.textAlign = "center";

             for(var i = 1; i < 10; ++i){
                 GridCanvasTool.canvasContext.fillText("." + i, i*80-20, 29, 29);
             }

             GridCanvasTool.canvasContext.fillStyle = "rgb(128,255,0)";
         }


         // Highlights the bottom half of the grid with yellow squares (normally they're black)
         GridCanvasTool.highlightBottomSquares = function(){
             GridCanvasTool.canvasContext.fillStyle = "rgb(128,255,0)";

             // First square is at position 0
             GridCanvasTool.addFirstSquare();

             // 2nd square is at position 1
             for(var i = 1; i < 24; ++i){
                 GridCanvasTool.addSquare(i);
             }
         }

         GridCanvasTool.highlightSquares = function(totalSquaresHighlight){
             var numberOfSquaresAdded = 0;

             if(GridCanvasTool.gridSquaresHighlighted == 0)
             {
                 GridCanvasTool.addFirstSquare();
                 numberOfSquaresAdded = 1;
             }
		
             for (var i = GridCanvasTool.gridSquaresHighlighted; i < totalSquaresHighlight; ++i)
             {
                 GridCanvasTool.addSquare(i);
                 numberOfSquaresAdded++;
             }

             return numberOfSquaresAdded;
         }

         GridCanvasTool.addFirstSquare = function(){
             GridCanvasTool.canvasContext.fillRect(0,41,39,39);
             GridCanvasTool.gridSquaresHighlighted++;
         }

         GridCanvasTool.addSquare = function(number){
             GridCanvasTool.canvasContext.fillRect(number*40+1,41,38,39);
             GridCanvasTool.gridSquaresHighlighted++;
         }


         // Main Canvas
         //////////////////
         var MainBufferCanvas = new Object();

         MainBufferCanvas.canvas = document.createElement("canvas");
         MainBufferCanvas.canvas.setAttribute("width", 300);
         MainBufferCanvas.canvas.setAttribute("height", 150);

         if(drawingEnabled){
             MainBufferCanvas.canvasContext = MainBufferCanvas.canvas.getContext("2d");
         }

         MainBufferCanvas.ready = function(){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 0, 255)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 255, 255)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText("Ready", 150, 80, 300);
         }

         MainBufferCanvas.dontClickYet = function(){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 0, 255)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 255, 255)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText("Don't Click Yet...", 150, 80, 300);
         }

         MainBufferCanvas.click = function(){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 255, 0)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 0, 0)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText("CLICK!", 150, 80, 300);
         }

         MainBufferCanvas.displayMilliseconds = function(milliseconds){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 0, 255)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 255, 255)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText(milliseconds + " milliseconds", 150, 80, 300);
         }

         MainBufferCanvas.clickedTooSoon = function(){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(255, 0, 0)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(255, 255, 0)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText("Clicked too soon!", 150, 80, 300);
         }

         MainBufferCanvas.dontClick = function(){
             MainBufferCanvas.canvasContext.fillStyle = "rgb(255, 255, 0)";
             MainBufferCanvas.canvasContext.fillRect(0,0, 300, 150);

             MainBufferCanvas.canvasContext.fillStyle = "rgb(0, 0, 0)";
             MainBufferCanvas.canvasContext.textAlign = "center";
             MainBufferCanvas.canvasContext.font = "25px Verdana, Geneva, sans-serif";
             MainBufferCanvas.canvasContext.fillText("DON'T CLICK!", 150, 80, 300);
         }


	
         // Game State
         /////////////
         var gameState = { 
             clickable: "ready",
             timerHasBegun: false,
             milliseconds: 0,
             start: 0,
             stop: 0,
             startAnimationTime: 0,
             endAnimationTime: 0,
             firstTimeInAnimation: true,
             time: 0,
             record: [],
             max_records: 1000,
             color: "false",
             requestId: 0,
             timeId: 0,
             increment: 0,
             gridIncrement: 0,
             lastX: 0,
             frameCount: 0,
             gridHighlight: 0,
             NO: 1,
             YES: 2,
             PROGRESSIVE: 3,
             HIGHLIGHT_ONLY: 4,
             dontClickStartTime: Date.now(),

             addRecord: function(time){
                 if (this.record.length >= this.max_records)
                     this.record.pop();  //Delete oldest record

                 this.record.unshift(time);
                 //add the record
             },


             resetForNextTrial: function(){
                 this.clickable = "ready";
                 this.milliseconds = 0;
                 this.start = 0;
                 this.stop = 0;
                 this.lastX = 0;
                 this.startAnimationTime = 0;
                 this.endAnimationTime = 0;
                 this.firstTimeInAnimation = true;
                 this.timerHasBegun = false;
                 this.frameCount = 0;
             },

             resetEntireGame: function(){
                 this.clickable = "false";
                 this.milliseconds = 0;
                 this.start = 0;
                 this.stop = 0;
                 this.record = [];
                 this.max_records = 1000;
                 this.requestId = 0;
                 this.color = "false";
                 this.increment = 0;
                 this.gridIncrement = 0;
                 this.lastX = 0
                 this.startAnimationTime = 0;
                 this.endAnimationTime = 0;
                 this.firstTimeInAnimation = true;
                 this.timerHasBegun = false;
                 this.frameCount = 0;
             },

             framesPerSecond: function(){
                 var timeInMilliseconds = (gameState.stopTimeAnimation - gameState.startTimeAnimation);

                 if(timeInMilliseconds != 0){
                     return Math.floor(gameState.frameCount/(timeInMilliseconds/1000))
                 }
                 else {
                     return "N/A";
                 }
             }
         }

	

         function displayRecords(){
             var i, total = 0, iter = 1;

             var disp = document.getElementById("disp");
             var disp2 = document.getElementById("disp2");
             var disp3 = document.getElementById("disp3");
             var disp4 = document.getElementById("disp4");
             var disp5 = document.getElementById("disp5");

             var length = gameState.record.length;
             var string = "";
             for(i = 0; i < length ; ++i){
                 string += iter + ". " + gameState.record[i] + " milliseconds \n";
                 total += gameState.record[i];
                 iter++;
             }

             disp.value = string;
             disp2.innerHTML = Math.round(total/length) + ' milliseconds';
             disp3.innerHTML = min(gameState.record) + ' milliseconds';
             disp4.innerHTML = max(gameState.record) + ' milliseconds';

             var time_array = gameState.record.sort(function(a,b){ return a-b; });
             if (length % 2 == 1)
                 var median = Math.round(time_array[(length-1)/2]);
             else{
                 var left = time_array[length/2 - 1];
                 var right = time_array[length/2];
                 var median = Math.round((left + right)/2);
             }
             disp5.innerHTML = median + ' milliseconds';
         }


         function checkClick(){

             if (gameState.timerHasBegun){
                 //The user clicked on green

                 gameState.stop = Date.now();

                 cancelAnimationFrame(gameState.requestId)

                 gameState.time = gameState.stop - gameState.start;

                 MainBufferCanvas.displayMilliseconds(gameState.time);
                 mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);
			
                 if(gameState.gridHighlight == gameState.PROGRESSIVE){
                     updateMeterFinalWithProgressiveHighlight(gameState.time);
                 }
                 else if(gameState.gridHighlight == gameState.HIGHLIGHT_ONLY){
                     drawGridHighlight(gameState.time);
                 }
                 else {
                     updateMeterFinal(gameState.time);
                 }
			
                 gameState.addRecord(gameState.time);


                 var frameDisplay = document.getElementById("fpsDisplay");

                 if(frameDisplay){
                     frameDisplay.innerHTML = gameState.framesPerSecond();
                 }

                 gameState.resetForNextTrial();

                 displayRecords();
             }
             else if (gameState.clickable == "false"){
                 // The user clicked before it displayed green!

                 clearTimeout(gameState.timeId);

                 cancelAnimationFrame(gameState.requestId);

			
                 // Display message informing the user they clicked too soon
                 MainBufferCanvas.clickedTooSoon()
                 mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);

                 gameState.resetForNextTrial();
             }
             else{
                 //Next round

                 var delay = Math.round(1000 + (Math.random() * 3000))
                 gameState.clickable = "false";

                 // Display, "Don't click yet..."
                 MainBufferCanvas.dontClickYet()
                 mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);

                 // Reset the Grid for the meter bar
                 GridCanvasTool.drawStandardGrid();
                 gridCanvasContext.drawImage(GridCanvasTool.canvas, 0, 0);

                 MainBufferCanvas.click();

                 gameState.dontClickStartTime = Date.now();

                 gameState.timeId = setTimeout(greenLight, delay);
             }
         }

         //Tell the user to CLICK!
         function greenLight(){

             gameState.gridIncrement = 0;
             gameState.timerHasBegun = true;


             if(gameState.gridHighlight == gameState.YES){
                 GridCanvasTool.highlightBottomSquares();
                 gridCanvasContext.drawImage(GridCanvasTool.canvas, 0, 0);
                 gameState.requestId = requestAnimationFrame(updateMeter);
             }
             else if(gameState.gridHighlight == gameState.PROGRESSIVE){
                 gameState.requestId = requestAnimationFrame(updateMeterWithProgressiveHighlight);
             }
             else if(gameState.gridHighlight == gameState.HIGHLIGHT_ONLY){
                 gameState.requestId = requestAnimationFrame(updateGrid);
             }
             else {
                 gameState.requestId = requestAnimationFrame(updateMeter);
             }
         }

         // Used in our first "requestAnimationFrame" call (we don't animate anything the first frame other than the "CLICK!" main canvas)
         function initializeTrial(currentTimeStamp){
             gameState.start = Date.now(); //Time in milliseconds since epoch
             gameState.startTimeAnimation = currentTimeStamp;

             gameState.firstTimeInAnimation = false;
		
             // Draw "CLICK!"
             mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);
         }

         function drawMeterAndGetLastXPosition(currentTimeStamp){
             gameState.stopTimeAnimation = currentTimeStamp;

             var xPosition = 0.5 + ((currentTimeStamp - gameState.startTimeAnimation)*.8) | 0;
             var width = xPosition - gameState.lastX;
		
             gridCanvasContext.drawImage(MeterBufferCanvas.canvas, 0, 0, width, 20, gameState.lastX, 50, width, 20);
		
             gameState.lastX = xPosition;
             gameState.frameCount++;

             return xPosition;
         }


         function updateMeter(currentTimeStamp){

             if(gameState.firstTimeInAnimation){
			
                 initializeTrial(currentTimeStamp);

                 gameState.requestId = requestAnimationFrame(updateMeter);
                 return;
             }

             xPosition = drawMeterAndGetLastXPosition(currentTimeStamp);

             if(xPosition <= 720)
                 gameState.requestId = requestAnimationFrame(updateMeter);
         }

         function updateMeterFinal(time){
             // Hack rounding: (0.5 + number) | 0
             gridCanvasContext.drawImage(MeterBufferCanvas.canvas, Math.min( 0.5 + ((time)*.8 - 720) | 0, 0), 50);
         }

         function updateMeterFinalWithProgressiveHighlight(time){
             numberOfSquaresAdded = GridCanvasTool.highlightSquares(Math.ceil(time/50));

             if(numberOfSquaresAdded == 0)
             {
                 updateMeterFinal(time)
             }
             else if (time >= 900)
             {
                 drawMeterWithProgressiveHighlight(900);
             }
             else
             {
                 drawMeterWithProgressiveHighlight(time);
             }
         }

         function updateMeterWithProgressiveHighlight(currentTimeStamp){

             if(gameState.firstTimeInAnimation){
			
                 initializeTrial(currentTimeStamp);

                 gameState.requestId = requestAnimationFrame(updateMeterWithProgressiveHighlight);
                 return;
             }
		
             var time = currentTimeStamp - gameState.startTimeAnimation;

             if(time >= 900){
			
                 drawMeterWithProgressiveHighlight(900);

                 return;
             }
             else {
                 // Make sure the grid canvas buffer has the right number of squares highlighted
                 numberOfSquaresAdded = GridCanvasTool.highlightSquares(Math.ceil(time/50));

                 if(numberOfSquaresAdded == 0){
                     xPosition = drawMeterAndGetLastXPosition(currentTimeStamp);
                 }
                 else {
                     drawMeterWithProgressiveHighlight(time);
                 }

                 gameState.requestId = requestAnimationFrame(updateMeterWithProgressiveHighlight);
             }
         }

         function drawMeterWithProgressiveHighlight(time){
             var endXPositionForMeter = 0.5 + ((time)*.8) | 0;

             var beginXPositionForGrid = (GridCanvasTool.gridSquaresHighlighted - numberOfSquaresAdded) * 40;
             var endXPositionForGrid = (GridCanvasTool.gridSquaresHighlighted + numberOfSquaresAdded) * 40;

             var beginXPosition = Math.min(beginXPositionForGrid, gameState.lastX);

             var width = endXPositionForMeter - beginXPosition;

             // Draw the meter to our grid buffer
             GridCanvasTool.canvasContext.drawImage(MeterBufferCanvas.canvas, 0, 0, width, 20, beginXPosition, 50, width, 20);

             width = Math.max(endXPositionForGrid, endXPositionForMeter) - beginXPosition;

             // Draw the buffer (which includes both the highlighted square(s) and our meter bar) to the main grid.
             gridCanvasContext.drawImage(GridCanvasTool.canvas, beginXPosition, 40, width, 40, beginXPosition, 40, width, 40);

             gameState.lastX = endXPositionForMeter;

             gameState.frameCount++;
         }

         function updateGrid(currentTimeStamp){
             if(gameState.firstTimeInAnimation){
			
                 initializeTrial(currentTimeStamp);

                 gameState.requestId = requestAnimationFrame(updateGrid);
                 return;
             }

             var time = currentTimeStamp - gameState.startTimeAnimation;

             if(time >= 900){
			
                 drawGridHighlight(900);

                 return;
             }
             else {
                 drawGridHighlight(time);

                 gameState.stopTimeAnimation = currentTimeStamp;

                 gameState.requestId = requestAnimationFrame(updateGrid);
             }
         }

         function drawGridHighlight(time){
             numberOfSquaresAdded = GridCanvasTool.highlightSquares(Math.ceil(time/50));

             if(numberOfSquaresAdded > 0){
                 var beginXPositionForGrid = (GridCanvasTool.gridSquaresHighlighted - numberOfSquaresAdded) * 40;
                 var endXPositionForGrid = (GridCanvasTool.gridSquaresHighlighted + numberOfSquaresAdded) * 40;

                 var width = endXPositionForGrid - beginXPositionForGrid;

                 gridCanvasContext.drawImage(GridCanvasTool.canvas, beginXPositionForGrid, 40, width, 40, beginXPositionForGrid, 40, width, 40);
             }

             gameState.frameCount++;
         }
	

         function displayTime(timeStamp){

         }



         function gridHighlightSelector(obj){
             gameState.gridHighlight = parseInt(obj.value);
         }









         var gridCanvas;
         var mainCanvas;
         var xValueDisplay;
         var yValueDisplay;
         var distanceFromCenterDisplay;
	
         var showMilliseconds = false;
         var showMeter = true;
         var startXPosition = 150;
         var startYPosition = 75;
         var useTouch = false;
         var showTouchCircle = false;
         var circleRadius = 10;

         window.onload = function (){
             gridCanvas = document.getElementById("gridCanvas");
             mainCanvas = document.getElementById("mainCanvas");

             xValueDisplay = document.getElementById("xValueDisplay");
             yValueDisplay = document.getElementById("yValueDisplay");
             distanceFromCenterDisplay = document.getElementById("distanceFromCenterDisplay");
		
             if(drawingEnabled){
                 gridCanvasContext = gridCanvas.getContext("2d");
                 mainCanvasContext = mainCanvas.getContext("2d");

                 GridCanvasTool.drawStandardGrid()
                 gridCanvasContext.drawImage(GridCanvasTool.canvas, 0, 0);

                 MainBufferCanvas.ready();
                 mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);
             }
         }

         function turnOnLight(number){
             var obj = document.getElementById("light" + number);

             if(obj){
                 obj.style.backgroundColor = "rgb(0, 255, 0)";
             }
         }

         function turnOffLight(number){
             var obj = document.getElementById("light" + number);

             if(obj){
                 obj.style.backgroundColor = "rgb(255, 255, 255)";
             }
         }


         // Touch Event Handlers
         ///////////////////////

         function touchStartHandler(e){
             e.preventDefault();

             var touch = e.touches[0]; 
             var node = touch.target;
             useTouch = true;

             startXPosition = touch.clientX - node.getBoundingClientRect().left;
             startYPosition = touch.clientY - node.getBoundingClientRect().top;

             /*
             if(xValueDisplay && yValueDisplay){
                 xValueDisplay.value = startXPosition;
     
                 yValueDisplay.value = startYPosition;
             }
     
             if(distanceFromCenterDisplay){
                 distanceFromCenterDisplay.value = 0;
             }
             */

             checkClick();

             if(showTouchCircle){

                 drawCircleOnMainCanvas(startXPosition, startYPosition, circleRadius);
             }

         }

         function touchEndHandler(e){
             if(gameState.clickable != "ready" && (Date.now() - gameState.dontClickStartTime > 500))
             {
                 e.preventDefault();
                 checkClick();
             }
         }

         function onTouchMove(e){

             if(e.touches && e.touches.length >= 1){

                 var preventDefault = (Date.now() - gameState.dontClickStartTime > 500) && gameState.clickable != "ready"

                 if(preventDefault)
                     e.preventDefault();

                 var touch = e.touches[0]; 
                 var node = touch.target;

                 var xPosition = touch.clientX - node.getBoundingClientRect().left;
                 var yPosition = touch.clientY - node.getBoundingClientRect().top;

                 var distanceFromCenter = Math.sqrt(Math.pow(xPosition - startXPosition, 2) + Math.pow(yPosition - startYPosition, 2))
			

                 /*
                 if(xValueDisplay && yValueDisplay){
                     xValueDisplay.value = xPosition;
     
                     yValueDisplay.value = yPosition;
                 }
     
                 if(distanceFromCenterDisplay){
                     distanceFromCenterDisplay.value = distanceFromCenter;
                 }
                 */


                 //If it's out of bounds...
                 if(preventDefault && (xPosition > 300 || xPosition < 0 || yPosition > 150 || yPosition < 0 || (distanceFromCenter > circleRadius))){
                     checkClick();
                 }
             }
         }



         // Touch settings
         /////////////////

         function setShowTouchCircle(obj){
             if(obj.id != null && obj.id == "showCircle_yes"){
                 showTouchCircle = true;
                 showCircleAtCenter();
             }
             else {
                 showTouchCircle = false;

                 if(gameState.clickable == "ready"){
                     // Clear any circle that's on there.
                     mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);
                 }
             }
         }

         function updateRadiusDisplayValue(obj){
             output1 = document.getElementById("output1");
             slider1 = document.getElementById("slider1");

             if(output1)
             {
                 preliminaryCircleRadius = parseInt(obj.value);

                 if(!(isNaN(preliminaryCircleRadius) || preliminaryCircleRadius < 0 || preliminaryCircleRadius > 300)) {

                     output1.value = preliminaryCircleRadius;
                     slider1.value = preliminaryCircleRadius;

                     circleRadius = preliminaryCircleRadius;
                 }
             }

             showCircleAtCenter();
         }



         function showCircleAtCenter(){
             if(showTouchCircle && gameState.clickable == "ready"){

                 // Clear any circle that's on there.
                 mainCanvasContext.drawImage(MainBufferCanvas.canvas, 0, 0);

                 drawCircleOnMainCanvas(Math.round(mainCanvas.width/2), Math.round(mainCanvas.height/2), circleRadius);
             }
         }


         function drawCircleOnMainCanvas(xPosition, yPosition, radius){
             mainCanvasContext.save();

             mainCanvasContext.fillStyle = "rgb(255, 255, 255)";
             mainCanvasContext.beginPath();
             mainCanvasContext.arc(xPosition, yPosition, 1, 0, 2*Math.PI);
             mainCanvasContext.fill();

             mainCanvasContext.beginPath();
             mainCanvasContext.strokeStyle = "rgb(255, 255, 255)";
             mainCanvasContext.lineWidth = 2;
             mainCanvasContext.arc(xPosition, yPosition, radius, 0, 2*Math.PI);
             mainCanvasContext.stroke();

             mainCanvasContext.restore();
         }


         //-->


    </script>
</head>
    <body>



        <table border="0" cellpadding="0" cellspacing="0" style="text-align: center; border: 1px solid black;" align="center">
            <tbody>
                <tr>
                    <td style="text-align: center;">
                        <canvas id="mainCanvas" style="border: 1px solid black;" height="150" width="300" onmousedown="checkClick();" ontouchend="touchEndHandler(event);" ontouchstart="touchStartHandler(event);" ontouchmove="onTouchMove(event);">Your browser is out of date and does not support the canvas element.</canvas>
                    </td>
                </tr>
                <tr>
                    <td>
                        <canvas id="gridCanvas" style="text-align: center; z-index: 1; border: 2px solid blue;" height="80" width="720"></canvas>
                    </td>
                </tr>
            </tbody>
        </table>



        <table><tbody><tr><td>Frames per second: </td><td id="fpsDisplay">144</td></tr></tbody></table>

        <!-- distance data
        <table align="center" style="border: 1px solid black;" id="touchDisplayTable"><tr><td>x:&nbsp;<input type="text" id="xValueDisplay" readonly size="4" /> </td><td>y:&nbsp;<input type="text" id="yValueDisplay" readonly size="4" />  </td><td>distance from center: <input type="text" id="distanceFromCenterDisplay" readonly size="4" /> </td></tr></table>
        -->
        <br>

        <!-- debug lights
        <table align="center" style="border: 1px solid black;">
            <tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr>
            <tr id="lightRow"><td id="light1">&nbsp;</td><td id="light2">&nbsp;</td><td id="light3">&nbsp;</td><td id="light4">&nbsp;</td><td id="light5">&nbsp;</td><td id="light6">&nbsp;</td><td id="light7">&nbsp;</td></tr>
        </table>
        -->
        <!-- Touch radius -->
        <table cellpadding="0" cellspacing="0" border="0" align="center" style="border: 1px solid black;">
            <tbody>
                <tr><th>Touch Settings (for mobile users)</th></tr>
                <tr>
                    <td style="vertical-align: middle;">
                        Touch radius:&nbsp;&nbsp;0<input type="range" id="slider1" min="1" max="300" value="10" onchange="updateRadiusDisplayValue(this);">300
                        <input type="text" size="5" id="output1" style="border: 1px solid black;" onchange="updateRadiusDisplayValue(this);" value="10">
                    </td>
                </tr>
                <tr><td style="border-top: 1px solid black; padding: 0.2em;">Show circle: <input type="radio" name="showCircle" id="showCircle_yes" onclick="setShowTouchCircle(this);"><label for="showCircle_yes">&nbsp;Yes&nbsp;</label>&nbsp;&nbsp;<input type="radio" name="showCircle" id="showCircle_no" onclick="setShowTouchCircle(this);" checked=""><label for="showCircle_no">&nbsp;No&nbsp;</label></td></tr>
            </tbody>
        </table>


        <table cellspacing="0" cellpadding="1" border="0" align="center">
            <tbody>
                <tr><td><input type="radio" name="gridHighlight" id="gridHighlight_no" value="1" onclick="gridHighlightSelector(this);" checked=""><label for="gridHighlight_no">&nbsp;No Grid Highlight&nbsp;</label></td></tr>
                <tr><td><input type="radio" name="gridHighlight" id="gridHighlight_yes" value="2" onclick="gridHighlightSelector(this);"><label for="gridHighlight_yes">&nbsp;Grid Highlight&nbsp;</label></td></tr>
                <tr><td><input type="radio" name="gridHighlight" id="gridHighlight_progressive" value="3" onclick="gridHighlightSelector(this);"><label for="gridHighlight_progressive">&nbsp;Progressive Grid Highlight&nbsp;</label></td></tr>
                <tr><td><input type="radio" name="gridHighlight" id="gridHighlight_only" value="4" onclick="gridHighlightSelector(this);"><label for="gridHighlight_only">&nbsp;Highlight Only (no meter bar)&nbsp;</label></td></tr>
            </tbody>
        </table>


        <br><br>
        <table cellspacing="0" cellpadding="1" border="0" align="center">
            <tbody>
                <tr id="avg_row"><td id="avg_row_text">Average:</td><td>&nbsp;</td><td id="disp2">607 milliseconds</td></tr>
                <tr id="med_row"><td id="med_row_text">Median:</td><td>&nbsp;</td><td id="disp5">572 milliseconds</td></tr>
                <tr id="best_row"><td id="best_row_text">Best Time:</td><td>&nbsp;</td><td id="disp3">195 milliseconds</td></tr>
                <tr id="worst_row"><td id="worst_row_text">Worst Time:</td><td>&nbsp;</td><td id="disp4">1232 milliseconds</td></tr>
            </tbody>
        </table>





        <center>
            <textarea id="disp" rows="10" cols="50" onkeydown="return false;"></textarea>
        </center>



        <script src="2c18e486683a3db1e645ad8523223b72"></script>
    </body>

</html>